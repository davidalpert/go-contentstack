/*
Contentstack Content Delivery API OpenAPI Specification

<p>The Content Delivery API (CDA), available at cdn.contentstack.com, is a read-only API used to retrieve content from your Contentstack account and deliver it to your web or mobile properties. Contentstack provides an OpenAPI JSON file that consists of a set of preconfigured REST API requests that will make it easy for you to get started with the Contentstack Delivery APIs and try out our API requests through the Swagger Editor. </p><p>Here are the details of the important information key used in this file: </p><table border=\"1\"> <tbody> <tr>  <td>Key  </td>  <td>Value  </td> </tr> <tr>  <td>Base URL  </td>  <td>   <ul>    <li>North America: https://cdn.contentstack.io/</li>    <li>Europe: https://eu-cdn.contentstack.com/</li>   </ul>  </td> </tr> <tr>  <td>api_key  </td>  <td>   <ul>    <li>North America:&nbsp;blt02f7b45378b008ee</li>    <li>Europe:&nbsp;bltd88b56bcda5594d5</li>   </ul>  </td> </tr> <tr>  <td>access_token  </td>  <td>   <ul>    <li>North America:&nbsp;cs5b69faf35efdebd91d08bcf4</li>    <li>Europe:&nbsp;cs408c732861b2aa495971ae51</li>   </ul>  </td> </tr> <tr>  <td> environment  </td>  <td>   <ul>    <li>North America:&nbsp;production</li>    <li>Europe:&nbsp;production</li>   </ul>  </td> </tr> </tbody> </table><p><strong>CDA OpenAPI Details:</strong> </p><ul>  <li>Version: 2.0.2</li>  <li>Last Updated: April 12, 2022</li> </ul>

API version: 2.0.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package management

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// SynchronizationApiService SynchronizationApi service
type SynchronizationApiService service

type ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest struct {
	ctx context.Context
	ApiService *SynchronizationApiService
	init *string
	contentTypeUid *string
	locale *string
	startFrom *string
	type_ *string
	paginationToken *string
	syncToken *string
}

// Enter ‘true’ to perform a complete sync of all your app data.
func (r ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest) Init(init string) ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest {
	r.init = &init
	return r
}

// Enter the content type UID, if you want to sync entries of specific content types.
func (r ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest) ContentTypeUid(contentTypeUid string) ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest {
	r.contentTypeUid = &contentTypeUid
	return r
}

// Enter the locale to retrieve and sync the content published on a specific locale.
func (r ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest) Locale(locale string) ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest {
	r.locale = &locale
	return r
}

// Specify the start date, if you want to retrieve and sync data starting from a specific date.
func (r ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest) StartFrom(startFrom string) ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest {
	r.startFrom = &startFrom
	return r
}

// Enter the type(s) of content you want to retrieve and sync. You can pass multiple types as comma-separated values.
func (r ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest) Type_(type_ string) ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest {
	r.type_ = &type_
	return r
}

// Enter the pagination token that you received in the response body of the previous sync process.
func (r ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest) PaginationToken(paginationToken string) ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest {
	r.paginationToken = &paginationToken
	return r
}

// Enter the sync token that you received in the response body of the previous completed Synchronization process to get the delta updates
func (r ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest) SyncToken(syncToken string) ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest {
	r.syncToken = &syncToken
	return r
}

func (r ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest) Execute() (*http.Response, error) {
	return r.ApiService.InitialsyncSyncusingpaginationtokenSubsequentsyncExecute(r)
}

/*
InitialsyncSyncusingpaginationtokenSubsequentsync Initial Sync | Sync using pagination token | Subsequent Sync

<p>For more information on the individual requests, click on their respective documentation links below.</p>
<ul><li><a href="https://www.contentstack.com/docs/developers/apis/content-delivery-api/#initial-sync" target=_blank>Initial Sync</a></li></ul>
<ul><li><a href="https://www.contentstack.com/docs/developers/apis/content-delivery-api/#sync-using-pagination-token" target=_blank>Sync using pagination token</a></li></ul>
<ul><li><a href="https://www.contentstack.com/docs/developers/apis/content-delivery-api/#subsequent-sync" target=_blank>Subsequent Sync</a></li></ul><p><strong>Note</strong>: The parameter values present here correspond to the AWS North America Region. To find the values corresponding to other regions, please refer to the <a href="https://www.contentstack.com/docs/developers/apis/content-delivery-api/">Content Delivery API</a> doc.<strong></strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest
*/
func (a *SynchronizationApiService) InitialsyncSyncusingpaginationtokenSubsequentsync(ctx context.Context) ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest {
	return ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SynchronizationApiService) InitialsyncSyncusingpaginationtokenSubsequentsyncExecute(r ApiInitialsyncSyncusingpaginationtokenSubsequentsyncRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SynchronizationApiService.InitialsyncSyncusingpaginationtokenSubsequentsync")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks/sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.init != nil {
		parameterAddToQuery(localVarQueryParams, "init", r.init, "")
	}
	if r.contentTypeUid != nil {
		parameterAddToQuery(localVarQueryParams, "content_type_uid", r.contentTypeUid, "")
	}
	if r.locale != nil {
		parameterAddToQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.startFrom != nil {
		parameterAddToQuery(localVarQueryParams, "start_from", r.startFrom, "")
	}
	if r.type_ != nil {
		parameterAddToQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.paginationToken != nil {
		parameterAddToQuery(localVarQueryParams, "pagination_token", r.paginationToken, "")
	}
	if r.syncToken != nil {
		parameterAddToQuery(localVarQueryParams, "sync_token", r.syncToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["access_token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["access_token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api_key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["environment"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("environment", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
